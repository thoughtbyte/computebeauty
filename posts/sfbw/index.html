<!DOCTYPE html>
<html lang="en">
  <meta charset="UTF-8" /><meta
    name="viewport"
    content="width=device-width,initial-scale=1"
  /><title>
    FizzBuzz Mario World: Learning ASM Programming & Having Fun with Super Mario</title
  ><link
    rel="stylesheet"
    type="text/css"
    href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css"
  /><link rel="stylesheet" type="text/css" href="../../main.css" />
  <main>
    <div class="heading">
      <h1>
        FizzBuzz Mario World: Learning ASM Programming & Having Fun with Super
        Mario
      </h1>
      <p class="date">06-01-2020</p>
    </div>
    <p>
      I've wanted to learn
      <a href="https://en.wikipedia.org/wiki/Assembly_language" target="_blank"
        >Assembly (ASM) language</a
      >
      programming for a long time. I finally found the perfect project to do it:
      hacking Super Mario World (SMW). It was a lot of fun so I thought I'd
      document the process.
    </p>
    <p>
      This post is intended for all audiences. Those already familiar with ASM
      can get a peak at the
      <a href="https://en.wikipedia.org/wiki/WDC_65C816" target="_blank"
        >65c816 microprocessor</a
      >
      and its implementation for the Super Nintendo (SNES). Those familiar with
      programming can get a gentle introduction to ASM. And my hope is that I've
      explained this stuff well enough so that anyone can appreciate the beauty
      of some of what goes on under the hood of the SNES.
    </p>
    <p>
      The SMW
      <a href="https://en.wikipedia.org/wiki/ROM_hacking" target="_blank"
        >ROM hacking</a
      >
      community is vibrant. It's an impressively talented and creative community
      that makes many versions of SMW with custom graphics, music, level design,
      and game physics. For example, check out
      <a href="https://www.youtube.com/watch?v=oH0T5G7IXtY" target="_blank"
        >this boss battle</a
      >
      from the popular hack JUMP 1/2. Somehow stumbling upon this hack and
      others like it on YouTube and Twitch started me down this rabbit hole.
    </p>
    <p>
      You can find the complete code and a list of the resources mentioned in
      this post on
      <a
        href="https://github.com/thoughtbyte/super-fizzbuzz-world"
        target="_blank"
        >GitHub</a
      >.
    </p>
    <h2>FizzBuzz Mario</h2>
    <p>
      <a href="https://en.wikipedia.org/wiki/Fizz_buzz" _target="blank"
        >FizzBuzz</a
      >
      is a common problem that beginner programmers solve for practice. The
      objective is to loop from 1 to 100 and:
    </p>
    <ul>
      <li>for every number divisible by 3, print 'fizz'</li>
      <li>for every number divisible by 5, print 'buzz'</li>
      <li>for every number divisible by 3 and 5, print 'fizz buzz'</li>
      <li>otherwise print the number</li>
    </ul>
    <p>
      The goal of this project is to solve a problem similar to FizzBuzz by
      writing custom ASM that can be patched into the SMW code. The perfect
      context for FizzBuzz in SMW is the coin count. At any one time the player
      can have between 0 and 99 coins. Additionally, Mario can have 1 of 4
      power-up statuses: small, big, cape, and fire. Here's the behavior we'll
      hack into our version of SMW:
    </p>
    <ul>
      <li>when coin count is divisible by 3, set status to big</li>
      <li>when coin count is divisible by 5, set status to cape</li>
      <li>when coin count is divisible by 3 and 5, set status to fire</li>
      <li>otherwise set status to small</li>
    </ul>
    <h2>Getting Started</h2>
    <p>
      After a few minutes of searching the web I found the source of most of the
      information I'll be sharing:
      <a href="https://www.smwcentral.net/" target="_blank">SWM Central</a>. You
      can find a full list of resources at the end of this article but the
      guides I found most helpful were Ersanio's
      <a
        href="https://ersanio.gitbook.io/assembly-for-the-snes/"
        target="_blank"
        >Assembly for the SNES</a
      >
      and
      <a
        href="https://www.smwcentral.net/?p=section&a=details&id=15073"
        target="_black"
        >Assembly for Super Mario World</a
      >. The former assumes no knowledge of ASM. The latter refreshes the ASM
      info. from the former and then goes into how to apply a simple patch
      similar to the one we'll be writing. Both are quick reads and I recommend
      them to any programmer that wants to know what ASM programming feels like.
    </p>
    <h3>Memory</h3>
    <p>
      ASM is a low-level language with which you deal directly with individual
      bytes of memory. SNES games are comprised of read-only memory (ROM) and
      random-access memory (RAM). You can think of the ROM as the game cartridge
      itself. It's where all the code for how the game works is stored. For
      example, the code that instructs the SNES what to do when the player gets
      1 coin is in ROM. This memory, as the name implies, is usually only ever
      read from. Our goal is to hack this ROM by overwriting a small part of it
      and thus changing how the game behaves.
    </p>
    <p>
      The RAM is on the SNES itself and it's where values are stored that will
      change while the game is played. The coin counter value needs to live in
      RAM because it changes often. The same goes for the player's power-up
      status.
    </p>
    <p>
      In both ROM and RAM, memory is a long list of addresses where values can
      be stored. These addresses are represented in
      <a href="https://en.wikipedia.org/wiki/Hexadecimal" target="_blank"
        >hexadecimal (hex)</a
      >. For our purposes we'll need to figure out the memory addresses in RAM
      where the values of the coin count and the power-up status are stored, and
      where in ROM we can insert some custom code.
    </p>
    <p>
      Fortunately, people have completely disassembled SMW and mapped the RAM
      and ROM, so finding what we need is a simple web search. The ROM map can
      be found on
      <a
        href="https://www.smwcentral.net/?p=memorymap&game=smw&u=0&address=&sizeOperation=%3D&sizeValue=&region[]=ram&type=*&description="
        target="_blank"
        >SMW Central</a
      >. The ROM begins at address <code>$7E0000</code> and ends at
      <code>$7FC800</code>. The <code>$</code> indicates hex. By searching a few
      relevant keywords I found that the coin count is stored at address
      <code>$7E0019</code> and the power-up status is stored at address
      <code>$7E00DBF</code>. The entry for power-up status also indicates the 4
      possible values for this address and what they mean: 1 for big Mario, 2
      for cape Mario, 3 for fire Mario, and 0 for small Mario.
    </p>
    <p>
      This gives us a basic idea of what our ASM code will need to do, in
      pseudocode:
    </p>
    <pre><code>get the value of RAM address $7E0019 (coin count)
  if that value is divisible by 15
    store 3 in RAM address $7E00DBF (power-up status)
  else if that value is divisible by 5
    store 2 in RAM address $7E00DBF
  else if that value is divisible by 3
    store 1 in RAM address $7E00DBF
  else store 0 in RAM address 7E00DBF</code></pre>
    <p>
      Now we need to figure out where to insert our code. I want this code to
      run whenever the player gets a coin so I searched for "coin count" within
      the ROM map and found <code>$008F1D</code>, a 30 byte subroutine that
      "handles actually increasing the player's coin count and giving a life
      from 100 coins." This is a good start, but we can't just insert code into
      30 bytes of ROM without seeing what it does. We will break everything if
      we're not careful. Unfortunately the ROM map on SWM Central doesn't have
      the actual code stored at this address. But then I found
      <a
        href="https://www.smwcentral.net/?p=section&a=details&id=21822"
        target="_blank"
        >All.log++</a
      >: a complete disassembly of the SMW source code, in ASM, with extensive
      comments and labels.
    </p>
    <p>
      Inspecting the disassembled SMW source code at this coin count subroutine
      address, I noticed that the actual coin count is increased at address
      <code>$008F25</code>. That is, this is the piece of ROM that literally
      adds 1 to the coin count every single time the player receives 1 coin. But
      instead of just increasing the coin count by 1, I want to patch the ROM so
      that when the code at this address gets executed, the SNES
      <i>also</i> runs my FizzBuzz code.
    </p>
    <p>
      Now we have all of the relevant memory addresses that we need, and we have
      the pseudocode that we need to run at the coin count increase ROM address.
      Time for the actual code.
    </p>

    <h2>Writing the Code</h2>
    <p>Our first two lines are easy:</p>
    <pre><code>!PowerUpStatus = $0019
!CoinCount = $0DBF</code></pre>
    <p>
      We simply set the RAM memory addresses that we need for the coin count and
      power-up status to some labels so they'll be easier to refer to in the
      code. Notice that we dropped the <code>7E</code> from both addresses. We
      don't need it. These lines don't actually get patched into the ROM. All
      occurrences of the labels in the code that we will write will get replaced
      with the addresses.
    </p>
    <h3>Hijacking the Coin Count Increase Code</h3>
    <p>
      We know where we want to insert our code: the address where the coin count
      is increased. But we can't insert <i>all</i> of our code into this
      address, we'll overwrite a lot of stuff and break the game. We can only
      insert a few bytes, and we have to make sure the bytes that we overwrite
      are executed by us in our own code so that everything that the original
      code was supposed to do still happens. So what we'll do is insert one
      instruction in the ROM at the coin count increase address that tells the
      processor to <i>jump</i> to the rest of our code, and we'll tell the
      assembler to insert our code in some free space, so we don't overwrite
      anything (sneak peak, at the end of our code we'll tell the SNES to jump
      back to where we jumped from, so the game continues as usual). Here's what
      that jump to our code looks like:
    </p>
    <pre><code>ORG $008F25
autoclean JSL FizzBuzz
NOP
NOP

freecode</code></pre>
    <p>
      <code>ORG $008F25</code> instructs the assembler to insert the following
      instruction directly after it into the ROM address where the coin count is
      increased. <code>autoclean</code> is used by the assembler to clean up the
      code if the patch is applied more than once. I applied the same patch
      dozens of times to a SMW ROM because it took me awhile to actually get it
      to work. This command just makes sure that applying the same patch over
      and over doesn't jack anything up.
    </p>
    <p>
      <code>JSL FizzBuzz</code> is the instruction that we place at the coin
      counter increase address. What it means is: <b>J</b>ump to the
      <b>S</b>ubroutine code labeled <code>FizzBuzz</code>. Most ASM operation
      codes, or opcodes, are menumonic. The J and S are for Jump and Subroutine.
      We can ignore the L, it's beyond the scope of this.
    </p>
    <p>
      As it turns out, the code I've chosen to overwrite, the coin count
      increase instruction and another instruction we'll get to at the end, is 6
      bytes long. The <code>JSL</code> instruction we insert is only 4 bytes
      long. But the code we insert needs to be the same size as the code we
      overwrite, otherwise there will be 2 bytes leftover that get executed out
      of the context of the 4 bytes that normally preceded them. To fill those 2
      bytes, we include 2 <code>NOP</code> instructions. These are
      <b>N</b>o-<b>OP</b>s, which just means no operations. We do nothing for 2
      byte to fill up the space not filled up by the 4 bytes of code we
      inserted. Remember, the 6 bytes of code that we overwrote will be executed
      in our custom code - as I mentioned earlier, we need to make sure we
      execute code we overwrite ourselves otherwise the game will likely break.
    </p>
    <pre><code>FizzBuzz:
INC !CoinCount
LDA #$0F
STA $00
LDA !CoinCount
JSR Mod</code></pre>
    <pre><code>BNE TestMod5
LDA #$03
STA !PowerUpStatus
BRA Return
TestMod5:</code></pre>
    <pre><code>LDA #$05
STA $00
LDA !CoinCount
JSR Mod
BNE TestMod3
LDA #$02
STA !PowerUpStatus
BRA Return</code></pre>
  </main>
</html>
